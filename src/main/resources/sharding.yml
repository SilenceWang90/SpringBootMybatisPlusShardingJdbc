dataSources:
  ds1:
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource # 必须指定数据源类型
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://localhost:3306/sharding_db?useSSL=false&serverTimezone=UTC
    username: root
    password: Wangpeng@90
  ds2:
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource # 必须指定数据源类型
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://localhost:3307/normal_db?useSSL=false&serverTimezone=UTC
    username: root
    password: root
rules:
  # !SHARDING是YAML中的一种标签（tag），用于标识这部分配置为Sharding规则。
  # 该配置不能省略，否则无法正确读取该配置文件。且下面还有!SINGLE配置是给所有表增加了默认的不分表的配置，如果表不再此处配置声明分表策略，将使用SINGLE的配置不分表查询
- !SHARDING
  tables:
    test:
      actualDataNodes: ds1.test$->{0..1}
      tableStrategy:
        standard:
          # 分片字段
          shardingColumn: id
          # 分片规则，自定义一个分片规则，名称随意，此处是test_inline
          shardingAlgorithmName: test_inline
  shardingAlgorithms:
    # 自定义的分片规则算法逻辑
    test_inline:
      type: INLINE
      props:
        # $是占位符，{id % 2}是该占位符的实现
        algorithm-expression: test$->{id % 2}
        # 允许支持范围查询，否则默认不支持
        allow-range-query-with-inline-sharding: true
# 1、该配置的作用是给没有指定分表策略的表指明数据源。必须有该配置，否则没有配置分表策略的表在查询的时候会报错，即使只有一个数据源也一样会报错。
# 其中第一个*代表数据库(数据源)名称，第二个*代表数据库表名称。即如果查询的表能匹配某个配置表达式，那么就依据匹配的表达式所对应的数据源查询数据，具体参见2示例的注释说明。
# 一般如果只配置了一个数据源(相当于只分表不分库)时，可以配置*.*，相当于所有的表默认不分表。假设某张表同时存在!SINGLE和!SHARDING的配置，执行!SHARDING分表逻辑，即!SHARDING优先级高于!SINGLE。
# 2、示例，如果如下配置：即意味着如果sql是查询no_sharding表，则从ds1这个数据源查询该表；如果sql是查询common_business，则从ds2数据源查询该表。
#      - "ds1.no_sharding"
#      - "ds2.common_business"
# 3、如果是有多个数据源，建议按照实际业务规则，指明不分表的表从哪个数据源查询。比如配置成ds2.*，即意味着所有的表如果没有配置分表策略，那么这些表都将从ds2这个数据源中查询。
# 4、如果多数据源时该配置也是*.*，那么shardingjdbc就会从默认的数据源查询表（暂未找到默认数据源的配置参数，但是此配置方式一直从ds2这个数据源查找，不清楚原理......）
- !SINGLE
  tables:
    - "ds2.*"
# 打印实际sql，否则只有逻辑sql。实际sql可以看出来具体查到了哪个分表上
props:
  sql-show: true